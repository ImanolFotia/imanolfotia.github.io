{"version":3,"file":"js/14-legacy.80843fb8.js","mappings":"mIAAA","sources":["webpack://imanolfotia.com/./src/markdowns/2017-03-11-ScreenSpaceReflections.md"],"sourcesContent":["export default \"Hello everyone!\\n\\nThis time I am updating the page with a rather tricky topic.\\n\\nThis is how (at the moment) I handle SSR in my engine. \\n\\nDon't forget to susbcribe to my YouTube channel and leave a comment about what you think!\\n\\n<iframe align=\\\"center\\\" width=\\\"1000\\\" height=\\\"562\\\" src=\\\"https://www.youtube.com/embed/K2rs7K4y_sY\\\" frameborder=\\\"0\\\" allowfullscreen></iframe>\\n\\n```cpp\\n\\n#version 400 core\\n\\nuniform sampler2D gFinalImage;\\nuniform sampler2D gPosition;\\nuniform sampler2D gNormal;\\nuniform sampler2D gExtraComponents;\\nuniform sampler2D ColorBuffer; \\n\\nuniform mat4 invView;\\nuniform mat4 projection;\\nuniform mat4 invprojection;\\nuniform mat4 view;\\n\\nnoperspective in vec2 TexCoords;\\n\\nout vec4 outColor;\\n\\nconst float step = 0.1;\\nconst float minRayStep = 0.1;\\nconst float maxSteps = 30;\\nconst int numBinarySearchSteps = 5;\\nconst float reflectionSpecularFalloffExponent = 3.0;\\n\\nfloat Metallic;\\n\\n#define Scale vec3(.8, .8, .8)\\n#define K 19.19\\n\\nvec3 PositionFromDepth(float depth);\\n\\nvec3 BinarySearch(inout vec3 dir, inout vec3 hitCoord, inout float dDepth);\\n \\nvec4 RayCast(vec3 dir, inout vec3 hitCoord, out float dDepth);\\n\\nvec3 fresnelSchlick(float cosTheta, vec3 F0);\\n\\nvec3 hash(vec3 a);\\n\\nvoid main()\\n{\\n\\n    vec2 MetallicEmmissive = texture2D(gExtraComponents, TexCoords).rg;\\n    Metallic = MetallicEmmissive.r;\\n\\n    if(Metallic < 0.01)\\n        discard;\\n \\n    vec3 viewNormal = vec3(texture2D(gNormal, TexCoords) * invView);\\n    vec3 viewPos = textureLod(gPosition, TexCoords, 2).xyz;\\n    vec3 albedo = texture(gFinalImage, TexCoords).rgb;\\n\\n    float spec = texture(ColorBuffer, TexCoords).w;\\n\\n    vec3 F0 = vec3(0.04); \\n    F0      = mix(F0, albedo, Metallic);\\n    vec3 Fresnel = fresnelSchlick(max(dot(normalize(viewNormal), normalize(viewPos)), 0.0), F0);\\n\\n    // Reflection vector\\n    vec3 reflected = normalize(reflect(normalize(viewPos), normalize(viewNormal)));\\n\\n\\n    vec3 hitPos = viewPos;\\n    float dDepth;\\n \\n    vec3 wp = vec3(vec4(viewPos, 1.0) * invView);\\n    vec3 jitt = mix(vec3(0.0), vec3(hash(wp)), spec);\\n    vec4 coords = RayMarch((vec3(jitt) + reflected * max(minRayStep, -viewPos.z)), hitPos, dDepth);\\n \\n \\n    vec2 dCoords = smoothstep(0.2, 0.6, abs(vec2(0.5, 0.5) - coords.xy));\\n \\n \\n    float screenEdgefactor = clamp(1.0 - (dCoords.x + dCoords.y), 0.0, 1.0);\\n\\n    float ReflectionMultiplier = pow(Metallic, reflectionSpecularFalloffExponent) * \\n                screenEdgefactor * \\n                -reflected.z;\\n \\n    // Get color\\n    vec3 SSR = textureLod(gFinalImage, coords.xy, 0).rgb * clamp(ReflectionMultiplier, 0.0, 0.9) * Fresnel;  \\n\\n    outColor = vec4(SSR, Metallic);\\n}\\n\\nvec3 PositionFromDepth(float depth) {\\n    float z = depth * 2.0 - 1.0;\\n\\n    vec4 clipSpacePosition = vec4(TexCoords * 2.0 - 1.0, z, 1.0);\\n    vec4 viewSpacePosition = invprojection * clipSpacePosition;\\n\\n    // Perspective division\\n    viewSpacePosition /= viewSpacePosition.w;\\n\\n    return viewSpacePosition.xyz;\\n}\\n\\nvec3 BinarySearch(inout vec3 dir, inout vec3 hitCoord, inout float dDepth)\\n{\\n    float depth;\\n\\n    vec4 projectedCoord;\\n \\n    for(int i = 0; i < numBinarySearchSteps; i++)\\n    {\\n\\n        projectedCoord = projection * vec4(hitCoord, 1.0);\\n        projectedCoord.xy /= projectedCoord.w;\\n        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\\n \\n        depth = textureLod(gPosition, projectedCoord.xy, 2).z;\\n\\n \\n        dDepth = hitCoord.z - depth;\\n\\n        dir *= 0.5;\\n        if(dDepth > 0.0)\\n            hitCoord += dir;\\n        else\\n            hitCoord -= dir;    \\n    }\\n\\n        projectedCoord = projection * vec4(hitCoord, 1.0);\\n        projectedCoord.xy /= projectedCoord.w;\\n        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\\n \\n    return vec3(projectedCoord.xy, depth);\\n}\\n\\nvec4 RayMarch(vec3 dir, inout vec3 hitCoord, out float dDepth)\\n{\\n\\n    dir *= step;\\n \\n \\n    float depth;\\n    int steps;\\n    vec4 projectedCoord;\\n\\n \\n    for(int i = 0; i < maxSteps; i++)\\n    {\\n        hitCoord += dir;\\n \\n        projectedCoord = projection * vec4(hitCoord, 1.0);\\n        projectedCoord.xy /= projectedCoord.w;\\n        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;\\n \\n        depth = textureLod(gPosition, projectedCoord.xy, 2).z;\\n        if(depth > 1000.0)\\n            continue;\\n \\n        dDepth = hitCoord.z - depth;\\n\\n        if((dir.z - dDepth) < 1.2)\\n        {\\n            if(dDepth <= 0.0)\\n            {   \\n                vec4 Result;\\n                Result = vec4(BinarySearch(dir, hitCoord, dDepth), 1.0);\\n\\n                return Result;\\n            }\\n        }\\n        \\n        steps++;\\n    }\\n \\n    \\n    return vec4(projectedCoord.xy, depth, 0.0);\\n}\\n\\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\\n{\\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\\n}\\n\\n\\nvec3 hash(vec3 a)\\n{\\n    a = fract(a * Scale);\\n    a += dot(a, a.yxz + K);\\n    return fract((a.xxy + a.yxx)*a.zyx);\\n}\\n\\n```\\n\\nYes, this is the whole thing!\\n\\nGNU General Public License v3.0 Licensed\";"],"names":[],"sourceRoot":""}